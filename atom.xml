<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Carry CA</title>
  
  <subtitle>I&#39;ll try</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.carryca.com/"/>
  <updated>2018-01-09T07:25:00.470Z</updated>
  <id>http://www.carryca.com/</id>
  
  <author>
    <name>丁国航</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Validate &amp; CommonUtils</title>
    <link href="http://www.carryca.com/2018/01/09/validateUtil/"/>
    <id>http://www.carryca.com/2018/01/09/validateUtil/</id>
    <published>2018-01-09T07:06:20.000Z</published>
    <updated>2018-01-09T07:25:00.470Z</updated>
    
    <content type="html"><![CDATA[<p><em>常有需要校验参数的需求，却又没有合适的工具可以使用</em><br><em>因此仿造spring web的校验机制，结合hibernate的校验功能，实现了这样一个小工具</em><br><em>其实还有一些有趣的小工具，虽然可能有各种的瑕疵或者各种原因没能竣工，不过还是蛮有趣的</em><br><em><a href="https://github.com/ding-guohang/common_util" target="_blank" rel="noopener">欢迎去看看 to github line</a></em><br><a id="more"></a></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ca.util.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Stopwatch;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.ArrayUtils;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.NotBlank;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.internal.metadata.core.ConstraintHelper;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidatorContext;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.google.common.base.Preconditions.checkArgument;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数校验工具</span></span><br><span class="line"><span class="comment"> * Spring的参数校验好像就是基于Hibernate的Validator实现类</span></span><br><span class="line"><span class="comment"> * 在寻找一个直接调用一下，就可以触发参数校验的方式……但是没找到</span></span><br><span class="line"><span class="comment"> * 自己写了一个依赖于Hibernate的，很麻烦的参数校验</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * updated at 17-01-13</span></span><br><span class="line"><span class="comment"> * 修改了一下ValidateUtil， 解决了用map的单例问题，自己实现了NotBlank的校验器，不然每次都要校验notnull和notBlank，太麻烦了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guohang.ding on 16-11-8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidateUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConstraintHelper helper = <span class="keyword">new</span> ConstraintHelper();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(ValidateUtil.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAMS_INVALID = <span class="string">"Params_Invalid"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_ERROR = <span class="string">"System_Error"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Class&lt;? extends ConstraintValidator&lt;? extends Annotation, ?&gt;&gt;,</span><br><span class="line">            ConstraintValidator&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        NotBlankValidator validator = <span class="keyword">new</span> NotBlankValidator();</span><br><span class="line">        cache.put(org.hibernate.validator.internal.constraintvalidators.NotBlankValidator.class, validator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkRequest</span><span class="params">(Object request)</span> </span>&#123;</span><br><span class="line">        checkArgument(request != <span class="keyword">null</span>, PARAMS_INVALID);</span><br><span class="line">        Stopwatch watch = Stopwatch.createStarted();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">            LOG.info(<span class="string">"validate request: &#123;&#125;"</span>, request);</span><br><span class="line"></span><br><span class="line">            Field[] fields = request.getClass().getDeclaredFields();</span><br><span class="line">            <span class="keyword">if</span> (ArrayUtils.isEmpty(fields)) &#123;</span><br><span class="line">                LOG.info(<span class="string">"empty fields for request: &#123;&#125;"</span>, request.getClass());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Annotation[] annotations;</span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                annotations = field.getDeclaredAnnotations();</span><br><span class="line">                <span class="keyword">if</span> (ArrayUtils.isEmpty(annotations)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (annotation.annotationType().getAnnotation(Constraint.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (CollectionUtils.isEmpty(helper.getAllValidatorClasses(annotation.annotationType()))) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;? extends ConstraintValidator&lt;? extends Annotation, ?&gt;&gt; clazz</span><br><span class="line">                            : helper.getAllValidatorClasses(annotation.annotationType())) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            ConstraintValidator validator = getValidator(clazz);</span><br><span class="line">                            validator.initialize(annotation);</span><br><span class="line"></span><br><span class="line">                            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                            Object req = field.get(request);</span><br><span class="line">                            valid = validator.isValid(req, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                                LOG.error(<span class="string">"invalid params, req-&#123;&#125;, val-&#123;&#125;, annotation-&#123;&#125;"</span>, req, field.getName(), annotation);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            LOG.error(<span class="string">"validator validate error"</span>, e);</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(SYSTEM_ERROR);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    checkArgument(valid, PARAMS_INVALID);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            LOG.info(<span class="string">"valid cost &#123;&#125;"</span>, watch.elapsed(TimeUnit.MILLISECONDS));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ConstraintValidator <span class="title">getValidator</span><span class="params">(Class&lt;? extends ConstraintValidator&lt;? extends Annotation, ?&gt;&gt; clazz)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        ConstraintValidator validator = cache.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (validator == <span class="keyword">null</span>) &#123;</span><br><span class="line">            LOG.info(<span class="string">"init validator: &#123;&#125;"</span>, clazz);</span><br><span class="line">            validator = clazz.newInstance();</span><br><span class="line">            ConstraintValidator value = cache.putIfAbsent(clazz, validator);</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                validator = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> validator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NotBlankValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">NotBlank</span>, <span class="title">CharSequence</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(NotBlank annotation)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(CharSequence charSequence, ConstraintValidatorContext constraintValidatorContext)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> charSequence != <span class="keyword">null</span> &amp;&amp; charSequence.toString().trim().length() &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;常有需要校验参数的需求，却又没有合适的工具可以使用&lt;/em&gt;&lt;br&gt;&lt;em&gt;因此仿造spring web的校验机制，结合hibernate的校验功能，实现了这样一个小工具&lt;/em&gt;&lt;br&gt;&lt;em&gt;其实还有一些有趣的小工具，虽然可能有各种的瑕疵或者各种原因没能竣工，不过还是蛮有趣的&lt;/em&gt;&lt;br&gt;&lt;em&gt;&lt;a href=&quot;https://github.com/ding-guohang/common_util&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;欢迎去看看 to github line&lt;/a&gt;&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://www.carryca.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="validate" scheme="http://www.carryca.com/tags/validate/"/>
    
  </entry>
  
  <entry>
    <title>个人博客搭建</title>
    <link href="http://www.carryca.com/2017/12/31/initBlog/"/>
    <id>http://www.carryca.com/2017/12/31/initBlog/</id>
    <published>2017-12-31T11:55:25.000Z</published>
    <updated>2018-01-09T06:11:52.237Z</updated>
    
    <content type="html"><![CDATA[<p><em>关于我如何搭建了自己的个人博客，以及遇到的一些奇怪的问题。</em><br><em>resources: <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo中文官网</a> &amp; <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">next主题中文官网</a> </em><br><a id="more"></a></p><h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><ul><li>Github Pages + Hexo</li></ul><h1 id="搭建Hexo"><a href="#搭建Hexo" class="headerlink" title="搭建Hexo"></a>搭建Hexo</h1><h2 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h2><ul><li>建议直接<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">官网</a>，上面有足够多和清晰的下载资源</li><li>官网慢的话，可以看看自己公司内网的资源，一般前端都会有一个公共的资源库</li></ul><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><ul><li>按照步骤，确保已经完成nodejs的安装</li><li>执行以下命令安装，如果npm较慢，可以指定国内资源方，一般公司也有<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g [--registry=http://*]</span><br><span class="line">hexo init &lt;folder&gt; #新建一个文件夹，作为你的博客目录, 以下以MyBlog代指</span><br><span class="line">cd MyBlog</span><br><span class="line">npm install</span><br><span class="line">hexo server #启动本地服务器, 默认端口4000, 因此可以在(localhost:4000)预览</span><br></pre></td></tr></table></figure></li></ul><h2 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h2><blockquote><p><em>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</em><br><em>为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。</em></p></blockquote><ul><li>主题在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网</a>就有很多选择</li><li>我懒，就使用了最常见的<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next</a></li><li>直接git clone下来某个主题，并放到MyBlog/themes目录下</li><li>在站点配置文件中找到themes关键字，并修改为next<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#克隆最新版本</span></span><br><span class="line"><span class="built_in">cd</span> ~/MyBlog  <span class="comment">#进入我的博客目录</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next.git themes/next</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改主题配置文件</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure></li></ul><h1 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h1><ul><li><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>修改站点配置文件，将功能部署在master分支<br><code>`bash</code><br>deploy:<br>type: git<br>repo: <a href="https://github.com/ding-guohang/ding-guohang.github.io.git" target="_blank" rel="noopener">https://github.com/ding-guohang/ding-guohang.github.io.git</a><br>branch: master</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 建议将源码保留在另一个分支，例如code</span><br><span class="line">```bash</span><br><span class="line">git init</span><br><span class="line">git checkout -b code</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;init code branch for codes&quot;</span><br><span class="line">git push --set-upstream origin code</span><br></pre></td></tr></table></figure></li></ul><h1 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h1><ul><li>我是学前辈在<a href="https://www.godaddy.com/" target="_blank" rel="noopener">Godaddy</a>上购买的域名</li><li>修改Github Pages对应的Repository的Setting，有填写绑定域名的地方</li><li><p>修改域名的DNS配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新增/修改一条Type为A的记录，使其Name为@，value为192.30.252.153</span><br><span class="line">新增/修改一条Type为CNAME的记录，使其Name为www，value为你的Github Pages的地址，例如ding-guohang.github.io</span><br></pre></td></tr></table></figure></li><li><p>事实上这还是不够的，如果你仔细观察就会发现，当你在github上配置了域名之后，你的master分支上增加了一个叫CNAME的文件，内容只有一行，就是你配置的域名，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.carryca.com</span><br></pre></td></tr></table></figure></li><li><p>但是每次你hexo g/d 都会更新master的代码，就需要重新在github上进行配置。因此推荐在当前分支(例如我的code)下，增加CNAME文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/MyBlog/<span class="built_in">source</span>  <span class="comment">#前文已经提到，我的博客目录在~/MyBlog</span></span><br><span class="line">touch CNAME</span><br><span class="line">vim CNAME  <span class="comment">#编辑内容并保存退出</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="博客更新"><a href="#博客更新" class="headerlink" title="博客更新"></a>博客更新</h1><ul><li>在code分支上进行更新<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate (hexo g) </span><br><span class="line">hexo deploy (hexo d)</span><br></pre></td></tr></table></figure></li></ul><h1 id="Sitemap-amp-RSS"><a href="#Sitemap-amp-RSS" class="headerlink" title="Sitemap &amp; RSS"></a>Sitemap &amp; RSS</h1><ul><li>也可以手动在主题配置文件中修改rss的值<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed</span><br><span class="line">npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure></li></ul><h1 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h1><ul><li>有一点发自肺腑的建议要告诉大家</li><li>一定做好备份</li><li>尤其是主题配置文件</li><li>没错，我就是没事儿瞎搞，搞ci了没法恢复，又没有备份，只能重新一点点配置的那个可怜虫</li><li>我是在source下新建了一个backup目录，每次修改之后把要备份的文件同步过来，然后扔到github保存，以后可能会搞个脚本自动同步吧</li><li>这是因为主题是从github克隆下来的，所以它并不能被你提交到你的github上。我建议大佬也可以尝试修改next的.git/config文件，把他搞到自己的仓库上，如果你不准备更新的话</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;关于我如何搭建了自己的个人博客，以及遇到的一些奇怪的问题。&lt;/em&gt;&lt;br&gt;&lt;em&gt;resources: &lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo中文官网&lt;/a&gt; &amp;amp; &lt;a href=&quot;http://theme-next.iissnan.com/getting-started.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;next主题中文官网&lt;/a&gt; &lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="杂项" scheme="http://www.carryca.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>滑动窗口的redis+lua实现</title>
    <link href="http://www.carryca.com/2017/12/24/slidingWindow/"/>
    <id>http://www.carryca.com/2017/12/24/slidingWindow/</id>
    <published>2017-12-23T19:07:29.000Z</published>
    <updated>2018-01-08T11:25:26.639Z</updated>
    
    <content type="html"><![CDATA[<p>lua脚本 + redis，实现滑动窗口用于限流<br><a id="more"></a></p><blockquote><p>每个key，在redis中是一个table<br>这个table中记录了多个block的count值， key就是 cnt0, cnt1, … cnt99 假设100个block</p></blockquote><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>计算当前时间所在的block， 计算上一个block<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (时间差已经超过一个duration) &#123;</span><br><span class="line">全部清空, 重新计数</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (当前block &gt; 上一个block) &#123;</span><br><span class="line">说明两个block中间的block，全部是之前的值，属于无效值，清除掉之后剩下的总数，就是当  前总流量</span><br><span class="line">&#125;    </span><br><span class="line">        <span class="keyword">if</span> (当前block &lt; 上一个block) &#123;</span><br><span class="line">                 说明绕了一圈了，上一个block到最后和<span class="number">0</span>到当前block的值，是无效值</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实这个算法，可以通过两份空间，来减少时间上的阻塞<br>但是因为redis执行lua脚本，本身就是原子的，所以双份空间毫无价值</p><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- KEYS[1] map key</span></span><br><span class="line"><span class="comment">-- ARGV[1] current time</span></span><br><span class="line"><span class="comment">-- ARGV[2] duration  窗口总长度</span></span><br><span class="line"><span class="comment">-- ARGV[3] limitation  限流数量</span></span><br><span class="line"><span class="comment">-- ARGV[4] precision  限流精度  duration / 窗口数量10 / 100 * 100  </span></span><br><span class="line"><span class="comment">-- ARGV[5] permits  操作增量 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">clear</span><span class="params">(i1, i2, key, count_key, dele)</span></span></span><br><span class="line">    <span class="keyword">local</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> id = i1, i2 <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> bkey = count_key .. <span class="string">":"</span> .. id;    <span class="comment">-- .. 是字符串拼接的意思</span></span><br><span class="line">        <span class="keyword">local</span> bcount = redis.call(<span class="string">'HGET'</span>, key, bkey)    <span class="comment">-- 取出每个block的count值，并累加</span></span><br><span class="line">        <span class="keyword">if</span> bcount <span class="keyword">then</span></span><br><span class="line">            sum = sum + <span class="built_in">tonumber</span>(bcount)</span><br><span class="line">            <span class="built_in">table</span>.<span class="built_in">insert</span>(dele, bkey)    <span class="comment">--  往dele表的末尾插入这些key干啥</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> count_key = <span class="string">"cnt"</span> <span class="comment">-- count</span></span><br><span class="line"><span class="keyword">local</span> ts_key = <span class="string">"ts"</span> <span class="comment">-- timestamp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> now = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])  <span class="comment">-- 1513498680  2017/12/17 16:18:00</span></span><br><span class="line"><span class="keyword">local</span> duration = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">local</span> precision = <span class="built_in">tonumber</span>(ARGV[<span class="number">4</span>])</span><br><span class="line"><span class="keyword">local</span> permits = <span class="built_in">tonumber</span>(ARGV[<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> blocks = <span class="built_in">math</span>.<span class="built_in">ceil</span>(duration / precision)  <span class="comment">-- 窗口数量 * 100 * 100 这是什么鬼, 会不是默认每个窗口还分为了1w份</span></span><br><span class="line"><span class="keyword">local</span> block_id = <span class="built_in">math</span>.<span class="built_in">floor</span>(now / precision) % blocks</span><br><span class="line"><span class="keyword">local</span> last_ts = redis.call(<span class="string">'HGET'</span>, key, ts_key)  <span class="comment">-- hget table field, 所以每个限流的key，是redis中的一个hash表</span></span><br><span class="line">last_ts = last_ts <span class="keyword">and</span> <span class="built_in">tonumber</span>(last_ts) <span class="keyword">or</span> <span class="number">0</span> <span class="comment">-- 上一次的时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这个大的if 是计算是否超过limit的</span></span><br><span class="line"><span class="keyword">if</span> last_ts ~= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> decr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">local</span> dele = &#123;&#125; <span class="comment">-- 创建一个空表</span></span><br><span class="line">    <span class="keyword">local</span> last_id = <span class="built_in">math</span>.<span class="built_in">floor</span>(last_ts / i) % blocks  <span class="comment">-- 不知道这个i是啥，所以我也不知道这个last_id有啥用，但是我猜测应该是上一次落到的block</span></span><br><span class="line">    <span class="keyword">local</span> elapsed = now - last_ts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> elapsed &gt;= duration <span class="keyword">then</span> <span class="comment">-- 已经是一个新的限流范围了</span></span><br><span class="line">        <span class="comment">-- clear all</span></span><br><span class="line">        clear(<span class="number">0</span>, blocks - <span class="number">1</span>, key, count_key, dele)</span><br><span class="line">        <span class="keyword">if</span> permits &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            redis.call(<span class="string">'HSET'</span>, key, ts_key, now)</span><br><span class="line">            redis.call(<span class="string">'HINCRBY'</span>, key, count_key, permits)  <span class="comment">--  总量</span></span><br><span class="line">            redis.call(<span class="string">'HINCRBY'</span>, key, count_key .. <span class="string">":"</span> .. block_id, permits) <span class="comment">-- 某个block的量</span></span><br><span class="line">            redis.call(<span class="string">'PEXPIRE'</span>, key, duration)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">elseif</span> block_id &gt; last_id <span class="keyword">then</span></span><br><span class="line">        decr = decr + clear(last_id + <span class="number">1</span>, block_id, key, count_key, dele)  <span class="comment">-- 已经过期的值</span></span><br><span class="line">    <span class="keyword">elseif</span> block_id &lt; last_id <span class="keyword">then</span></span><br><span class="line">        decr = decr + clear(<span class="number">0</span>, block_id, key, count_key, dele)</span><br><span class="line">        decr = decr + clear(last_id + <span class="number">1</span>, blocks - <span class="number">1</span>, key, count_key, dele)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> cur</span><br><span class="line">    <span class="keyword">if</span> #dele &gt; <span class="number">0</span> <span class="keyword">then</span> <span class="comment">-- dele 不为空</span></span><br><span class="line">        redis.call(<span class="string">'HDEL'</span>, key, <span class="built_in">unpack</span>(dele)) <span class="comment">-- unpack 返回dele中所有值, 这里是删除这个表中所有失效的block</span></span><br><span class="line">        cur = redis.call(<span class="string">'HINCRBY'</span>, key, count_key, -decr)  <span class="comment">-- 总量减去过期的数据</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cur = redis.call(<span class="string">'HGET'</span>, key, count_key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">tonumber</span>(cur <span class="keyword">or</span> <span class="string">'0'</span>) + permits &gt; limit <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这个if是增量的</span></span><br><span class="line"><span class="keyword">if</span> permits &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">'HSET'</span>, key, ts_key, now)</span><br><span class="line">    redis.call(<span class="string">'HINCRBY'</span>, key, count_key, permits)  <span class="comment">-- H incr by</span></span><br><span class="line">    redis.call(<span class="string">'HINCRBY'</span>, key, count_key .. <span class="string">":"</span> .. block_id, permits)</span><br><span class="line">    redis.call(<span class="string">'PEXPIRE'</span>, key, duration)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;lua脚本 + redis，实现滑动窗口用于限流&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://www.carryca.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="限流" scheme="http://www.carryca.com/tags/%E9%99%90%E6%B5%81/"/>
    
      <category term="redis" scheme="http://www.carryca.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Kafka Note One: 初次见面, 请多关照</title>
    <link href="http://www.carryca.com/2017/12/23/kafkaNote1/"/>
    <id>http://www.carryca.com/2017/12/23/kafkaNote1/</id>
    <published>2017-12-23T13:03:54.000Z</published>
    <updated>2017-12-23T18:22:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>这是我对于kafka的学习过程中的一些笔记，可能大多数的信息来源于官方网站的翻译，以及网上的其他blog。</em><br><em>也许会参杂着一些自己的思考和认知，如果你需要一个入门、基础知识的快速阅览，也许会适合你。</em><br><em>resources: <a href="http://www.infoq.com/cn/articles/kafka-analysis-part-1/" target="_blank" rel="noopener">infoQ</a> &amp; <a href="http://kafka.apache.org/" target="_blank" rel="noopener">kafka官网</a></em><br><a id="more"></a></p><h1 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h1><ul><li>Topic, 也可以被成为subject, 发布-订阅模型中的消息主题</li><li>不同的Topic在物理上分开存储</li></ul><h1 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h1><blockquote class="blockquote-center"><p>For each topic, the Kafka cluster maintains a partitioned log </p></blockquote><ul><li>一种物理上的概念, 每个Partition在物理上对应一个文件夹，文件夹下存放的是这个Partition的所有消息和索引文件</li><li>Partition内的消息是有序的</li><li>这更像是一个日志文件，和对应的多个索引</li></ul><h2 id="一个Topic，被分为多个Partition"><a href="#一个Topic，被分为多个Partition" class="headerlink" title="一个Topic，被分为多个Partition"></a>一个Topic，被分为多个Partition</h2><p><img src="/img/anatomy of topic.png" alt="anatomy of topic"></p><ul><li>减小日志文件大小，让服务器可以承担</li><li>多个partition可以被并行消费</li></ul><h2 id="一个Partition里的日志文件，被分为多个Segment"><a href="#一个Partition里的日志文件，被分为多个Segment" class="headerlink" title="一个Partition里的日志文件，被分为多个Segment"></a>一个Partition里的日志文件，被分为多个Segment</h2><p><img src="/img/partition.png" alt=""></p><ul><li>每个日志，或者说每个消息，都具备自己在partition中的一个64byte的唯一offset，而且每个partition是有序的</li><li>每个Segment以自己包含的第一条消息的offset + “.kafka” 命名</li><li>有一个索引文件，表明了每个segment下包含的log的offset范围<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">日志的组成</span><br><span class="line">message length ： 4 bytes (value: 1+4+n)</span><br><span class="line">&quot;magic&quot; value ： 1 byte </span><br><span class="line">CRC 校验码 ： 4 bytes </span><br><span class="line">消息内容 ： n bytes</span><br></pre></td></tr></table></figure></li></ul><h2 id="消息的读取是O-1-的（这句话待求证）"><a href="#消息的读取是O-1-的（这句话待求证）" class="headerlink" title="消息的读取是O(1)的（这句话待求证）"></a>消息的读取是O(1)的（这句话待求证）</h2><blockquote class="blockquote-center"><p>Kafka’s performance is effectively constant with respect to data size so storing data for a long time is not a problem </p></blockquote><ul><li>Kafka会保留所有的消息，与是否被消费无关</li><li>可以指定删除旧数据的策略， 时间/partition文件大小</li><li>文件的大小和多少，不会影响kafka的性能</li></ul><p><img src="/img/consumer and provider.png" alt=""></p><h2 id="Consumer保存自己消费的offset，consumer之间互不影响"><a href="#Consumer保存自己消费的offset，consumer之间互不影响" class="headerlink" title="Consumer保存自己消费的offset，consumer之间互不影响"></a>Consumer保存自己消费的offset，consumer之间互不影响</h2><ul><li>因此kafka的broker是无状态的，也不需要锁</li><li>consumer可以通过修改自己的offset达到重新消费消息的效果</li><li>consumer去broker pull消息</li></ul><h1 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h1><ul><li>producer 选择自己的每一条消息记录到哪个partition中</li><li>最简单的方式就是循环，可以保证负载均衡</li><li>也可以通过某些消息中的某些元素自定义</li></ul><h1 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h1><blockquote class="blockquote-center"><p>The way consumption is implemented in Kafka is by dividing up the partitions in the log over the consumer instances so that each instance is the exclusive consumer of a “fair share” of partitions at any point in time </p></blockquote><p><img src="/img/consumer-groups.png" alt=""></p><ul><li>consumer有group的概念，一个group的所有实例，一起消费相同的topic</li><li>每个消息只会被交付给consumer group中的一个实例</li><li>kafka 关于这个的实现方式是将 partition划分到消费者实例上，使得在任何时间点上，每个实例都是将partitions公平分享的独占消费者</li><li>关于这一点，newQMQ就有刻意的区别实现，做了动态的关联</li><li>这个对应关系，是由kafka的协议动态维护的，所以任何消费者实例的变化，都会导致对应关系的变化</li><li>不需要区分订阅或是广播，所有消息都是订阅，如果每个consumer有独一无二的group，就是广播</li><li>kafka只保证每个partition有序，不保证多个partition的顺序，所以整体来说，其实是不保证消息有序的，如果想要整体顺序消费，那么只能通过一个partitoon的方式实现，这样带来的后果是也只会有一个consumer消费消息</li><li>关于这一点，newQMQ也有做一些特殊的处理，如果真的想要强顺序的话，貌似是可以实现的，虽然不知道效果是不是和这个一样</li></ul><h1 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h1><ul><li>partition 分布在kafka的集群上，每个server处理数据并请求共享分区，每个 partition 被复制在多个(可配)服务器上以实现容错</li><li>每个 partition 有一个server是leader，0或多个followers</li><li>leader处理读写请求，其他followers被动复制</li><li>leader挂了，某个followers自动变为leader</li><li>每个server都扮演一些 partition 的leader，和另一些的follower，因此load在集群中很平衡</li><li>当然，以此推论，如果只有一个server，则独自扮演所有topic的所有partition的leader，并且没有follower</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;这是我对于kafka的学习过程中的一些笔记，可能大多数的信息来源于官方网站的翻译，以及网上的其他blog。&lt;/em&gt;&lt;br&gt;&lt;em&gt;也许会参杂着一些自己的思考和认知，如果你需要一个入门、基础知识的快速阅览，也许会适合你。&lt;/em&gt;&lt;br&gt;&lt;em&gt;resources: &lt;a href=&quot;http://www.infoq.com/cn/articles/kafka-analysis-part-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;infoQ&lt;/a&gt; &amp;amp; &lt;a href=&quot;http://kafka.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kafka官网&lt;/a&gt;&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://www.carryca.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MQ" scheme="http://www.carryca.com/tags/MQ/"/>
    
      <category term="Kafka" scheme="http://www.carryca.com/tags/Kafka/"/>
    
  </entry>
  
</feed>
