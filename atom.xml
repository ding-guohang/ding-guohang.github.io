<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Carry CA</title>
  
  <subtitle>I&#39;ll try</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.carryca.com/"/>
  <updated>2018-01-08T12:28:36.894Z</updated>
  <id>http://www.carryca.com/</id>
  
  <author>
    <name>丁国航</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>个人博客搭建</title>
    <link href="http://www.carryca.com/2017/12/31/initBlog/"/>
    <id>http://www.carryca.com/2017/12/31/initBlog/</id>
    <published>2017-12-31T11:55:25.000Z</published>
    <updated>2018-01-08T12:28:36.894Z</updated>
    
    <content type="html"><![CDATA[<p><em>关于我如何搭建了自己的个人博客，以及遇到的一些奇怪的问题。</em><br><em>resources: <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo中文官网</a> &amp; <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">next主题中文官网</a> </em><br><a id="more"></a></p><h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><ul><li>Github Pages + Hexo</li></ul><h1 id="搭建Hexo"><a href="#搭建Hexo" class="headerlink" title="搭建Hexo"></a>搭建Hexo</h1><h2 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h2><ul><li>建议直接<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">官网</a>，上面有足够多和清晰的下载资源</li><li>官网慢的话，可以看看自己公司内网的资源，一般前端都会有一个公共的资源库</li></ul><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><ul><li>按照步骤，确保已经完成nodejs的安装</li><li>执行以下命令安装，如果npm较慢，可以指定国内资源方，一般公司也有<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g [--registry=http://*]</span><br><span class="line">hexo init &lt;folder&gt; #新建一个文件夹，作为你的博客目录, 以下以MyBlog代指</span><br><span class="line">cd MyBlog</span><br><span class="line">npm install</span><br><span class="line">hexo server #启动本地服务器, 默认端口4000, 因此可以在(localhost:4000)预览</span><br></pre></td></tr></table></figure></li></ul><h2 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h2><blockquote><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。<br>为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。</p></blockquote><ul><li>主题在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网</a>就有很多选择</li><li>我懒，就使用了最常见的<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next</a></li><li>直接git clone下来某个主题，并放到MyBlog/themes目录下</li><li>在站点配置文件中找到themes关键字，并修改为next<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#克隆最新版本</span><br><span class="line">cd MyBlog  #进入我的博客目录</span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next.git themes/next</span><br><span class="line"></span><br><span class="line">#修改主题配置文件</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure></li></ul><h1 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h1><ul><li><p>安装插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>修改站点配置文件，将功能部署在master分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/ding-guohang/ding-guohang.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>建议将源码保留在另一个分支，例如code<br>···<br>git init<br>git checkout -b code<br>git add .<br>git commit -m “init code branch for codes”<br>git push –set-upstream origin code<br>···</p></li></ul><h1 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h1><ul><li>我是学前辈在<a href="https://www.godaddy.com/" target="_blank" rel="noopener">Godaddy</a>上购买的域名</li><li>修改Github Pages对应的Repository的Setting，有填写绑定域名的地方</li><li>修改域名的DNS配置<br><strong> 新增/修改一条Type为A的记录，使其Name为@，value为192.30.252.153</strong> 新增/修改一条Type为CNAME的记录，使其Name为WWW，value为你的Github Pages的地址</li></ul><h1 id="博客更新"><a href="#博客更新" class="headerlink" title="博客更新"></a>博客更新</h1><ul><li>在code分支上进行更新<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate (hexo g) </span><br><span class="line">hexo deploy (hexo d)</span><br></pre></td></tr></table></figure></li></ul><h1 id="Sitemap-amp-RSS"><a href="#Sitemap-amp-RSS" class="headerlink" title="Sitemap &amp; RSS"></a>Sitemap &amp; RSS</h1><ul><li>也可以手动在主题配置文件中修改rss的值<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed</span><br><span class="line">npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;关于我如何搭建了自己的个人博客，以及遇到的一些奇怪的问题。&lt;/em&gt;&lt;br&gt;&lt;em&gt;resources: &lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo中文官网&lt;/a&gt; &amp;amp; &lt;a href=&quot;http://theme-next.iissnan.com/getting-started.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;next主题中文官网&lt;/a&gt; &lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="杂项" scheme="http://www.carryca.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>滑动窗口的redis+lua实现</title>
    <link href="http://www.carryca.com/2017/12/24/slidingWindow/"/>
    <id>http://www.carryca.com/2017/12/24/slidingWindow/</id>
    <published>2017-12-23T19:07:29.000Z</published>
    <updated>2018-01-08T11:25:26.639Z</updated>
    
    <content type="html"><![CDATA[<p>lua脚本 + redis，实现滑动窗口用于限流<br><a id="more"></a></p><blockquote><p>每个key，在redis中是一个table<br>这个table中记录了多个block的count值， key就是 cnt0, cnt1, … cnt99 假设100个block</p></blockquote><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>计算当前时间所在的block， 计算上一个block<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (时间差已经超过一个duration) &#123;</span><br><span class="line">全部清空, 重新计数</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (当前block &gt; 上一个block) &#123;</span><br><span class="line">说明两个block中间的block，全部是之前的值，属于无效值，清除掉之后剩下的总数，就是当  前总流量</span><br><span class="line">&#125;    </span><br><span class="line">        <span class="keyword">if</span> (当前block &lt; 上一个block) &#123;</span><br><span class="line">                 说明绕了一圈了，上一个block到最后和<span class="number">0</span>到当前block的值，是无效值</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实这个算法，可以通过两份空间，来减少时间上的阻塞<br>但是因为redis执行lua脚本，本身就是原子的，所以双份空间毫无价值</p><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- KEYS[1] map key</span></span><br><span class="line"><span class="comment">-- ARGV[1] current time</span></span><br><span class="line"><span class="comment">-- ARGV[2] duration  窗口总长度</span></span><br><span class="line"><span class="comment">-- ARGV[3] limitation  限流数量</span></span><br><span class="line"><span class="comment">-- ARGV[4] precision  限流精度  duration / 窗口数量10 / 100 * 100  </span></span><br><span class="line"><span class="comment">-- ARGV[5] permits  操作增量 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">clear</span><span class="params">(i1, i2, key, count_key, dele)</span></span></span><br><span class="line">    <span class="keyword">local</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> id = i1, i2 <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> bkey = count_key .. <span class="string">":"</span> .. id;    <span class="comment">-- .. 是字符串拼接的意思</span></span><br><span class="line">        <span class="keyword">local</span> bcount = redis.call(<span class="string">'HGET'</span>, key, bkey)    <span class="comment">-- 取出每个block的count值，并累加</span></span><br><span class="line">        <span class="keyword">if</span> bcount <span class="keyword">then</span></span><br><span class="line">            sum = sum + <span class="built_in">tonumber</span>(bcount)</span><br><span class="line">            <span class="built_in">table</span>.<span class="built_in">insert</span>(dele, bkey)    <span class="comment">--  往dele表的末尾插入这些key干啥</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> count_key = <span class="string">"cnt"</span> <span class="comment">-- count</span></span><br><span class="line"><span class="keyword">local</span> ts_key = <span class="string">"ts"</span> <span class="comment">-- timestamp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> now = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])  <span class="comment">-- 1513498680  2017/12/17 16:18:00</span></span><br><span class="line"><span class="keyword">local</span> duration = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">local</span> precision = <span class="built_in">tonumber</span>(ARGV[<span class="number">4</span>])</span><br><span class="line"><span class="keyword">local</span> permits = <span class="built_in">tonumber</span>(ARGV[<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> blocks = <span class="built_in">math</span>.<span class="built_in">ceil</span>(duration / precision)  <span class="comment">-- 窗口数量 * 100 * 100 这是什么鬼, 会不是默认每个窗口还分为了1w份</span></span><br><span class="line"><span class="keyword">local</span> block_id = <span class="built_in">math</span>.<span class="built_in">floor</span>(now / precision) % blocks</span><br><span class="line"><span class="keyword">local</span> last_ts = redis.call(<span class="string">'HGET'</span>, key, ts_key)  <span class="comment">-- hget table field, 所以每个限流的key，是redis中的一个hash表</span></span><br><span class="line">last_ts = last_ts <span class="keyword">and</span> <span class="built_in">tonumber</span>(last_ts) <span class="keyword">or</span> <span class="number">0</span> <span class="comment">-- 上一次的时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这个大的if 是计算是否超过limit的</span></span><br><span class="line"><span class="keyword">if</span> last_ts ~= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> decr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">local</span> dele = &#123;&#125; <span class="comment">-- 创建一个空表</span></span><br><span class="line">    <span class="keyword">local</span> last_id = <span class="built_in">math</span>.<span class="built_in">floor</span>(last_ts / i) % blocks  <span class="comment">-- 不知道这个i是啥，所以我也不知道这个last_id有啥用，但是我猜测应该是上一次落到的block</span></span><br><span class="line">    <span class="keyword">local</span> elapsed = now - last_ts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> elapsed &gt;= duration <span class="keyword">then</span> <span class="comment">-- 已经是一个新的限流范围了</span></span><br><span class="line">        <span class="comment">-- clear all</span></span><br><span class="line">        clear(<span class="number">0</span>, blocks - <span class="number">1</span>, key, count_key, dele)</span><br><span class="line">        <span class="keyword">if</span> permits &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            redis.call(<span class="string">'HSET'</span>, key, ts_key, now)</span><br><span class="line">            redis.call(<span class="string">'HINCRBY'</span>, key, count_key, permits)  <span class="comment">--  总量</span></span><br><span class="line">            redis.call(<span class="string">'HINCRBY'</span>, key, count_key .. <span class="string">":"</span> .. block_id, permits) <span class="comment">-- 某个block的量</span></span><br><span class="line">            redis.call(<span class="string">'PEXPIRE'</span>, key, duration)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">elseif</span> block_id &gt; last_id <span class="keyword">then</span></span><br><span class="line">        decr = decr + clear(last_id + <span class="number">1</span>, block_id, key, count_key, dele)  <span class="comment">-- 已经过期的值</span></span><br><span class="line">    <span class="keyword">elseif</span> block_id &lt; last_id <span class="keyword">then</span></span><br><span class="line">        decr = decr + clear(<span class="number">0</span>, block_id, key, count_key, dele)</span><br><span class="line">        decr = decr + clear(last_id + <span class="number">1</span>, blocks - <span class="number">1</span>, key, count_key, dele)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> cur</span><br><span class="line">    <span class="keyword">if</span> #dele &gt; <span class="number">0</span> <span class="keyword">then</span> <span class="comment">-- dele 不为空</span></span><br><span class="line">        redis.call(<span class="string">'HDEL'</span>, key, <span class="built_in">unpack</span>(dele)) <span class="comment">-- unpack 返回dele中所有值, 这里是删除这个表中所有失效的block</span></span><br><span class="line">        cur = redis.call(<span class="string">'HINCRBY'</span>, key, count_key, -decr)  <span class="comment">-- 总量减去过期的数据</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cur = redis.call(<span class="string">'HGET'</span>, key, count_key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">tonumber</span>(cur <span class="keyword">or</span> <span class="string">'0'</span>) + permits &gt; limit <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这个if是增量的</span></span><br><span class="line"><span class="keyword">if</span> permits &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">'HSET'</span>, key, ts_key, now)</span><br><span class="line">    redis.call(<span class="string">'HINCRBY'</span>, key, count_key, permits)  <span class="comment">-- H incr by</span></span><br><span class="line">    redis.call(<span class="string">'HINCRBY'</span>, key, count_key .. <span class="string">":"</span> .. block_id, permits)</span><br><span class="line">    redis.call(<span class="string">'PEXPIRE'</span>, key, duration)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;lua脚本 + redis，实现滑动窗口用于限流&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://www.carryca.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="限流" scheme="http://www.carryca.com/tags/%E9%99%90%E6%B5%81/"/>
    
      <category term="redis" scheme="http://www.carryca.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Kafka Note One: 初次见面, 请多关照</title>
    <link href="http://www.carryca.com/2017/12/23/kafkaNote1/"/>
    <id>http://www.carryca.com/2017/12/23/kafkaNote1/</id>
    <published>2017-12-23T13:03:54.000Z</published>
    <updated>2017-12-23T18:22:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>这是我对于kafka的学习过程中的一些笔记，可能大多数的信息来源于官方网站的翻译，以及网上的其他blog。</em><br><em>也许会参杂着一些自己的思考和认知，如果你需要一个入门、基础知识的快速阅览，也许会适合你。</em><br><em>resources: <a href="http://www.infoq.com/cn/articles/kafka-analysis-part-1/" target="_blank" rel="noopener">infoQ</a> &amp; <a href="http://kafka.apache.org/" target="_blank" rel="noopener">kafka官网</a></em><br><a id="more"></a></p><h1 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h1><ul><li>Topic, 也可以被成为subject, 发布-订阅模型中的消息主题</li><li>不同的Topic在物理上分开存储</li></ul><h1 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h1><blockquote class="blockquote-center"><p>For each topic, the Kafka cluster maintains a partitioned log </p></blockquote><ul><li>一种物理上的概念, 每个Partition在物理上对应一个文件夹，文件夹下存放的是这个Partition的所有消息和索引文件</li><li>Partition内的消息是有序的</li><li>这更像是一个日志文件，和对应的多个索引</li></ul><h2 id="一个Topic，被分为多个Partition"><a href="#一个Topic，被分为多个Partition" class="headerlink" title="一个Topic，被分为多个Partition"></a>一个Topic，被分为多个Partition</h2><p><img src="/img/anatomy of topic.png" alt="anatomy of topic"></p><ul><li>减小日志文件大小，让服务器可以承担</li><li>多个partition可以被并行消费</li></ul><h2 id="一个Partition里的日志文件，被分为多个Segment"><a href="#一个Partition里的日志文件，被分为多个Segment" class="headerlink" title="一个Partition里的日志文件，被分为多个Segment"></a>一个Partition里的日志文件，被分为多个Segment</h2><p><img src="/img/partition.png" alt=""></p><ul><li>每个日志，或者说每个消息，都具备自己在partition中的一个64byte的唯一offset，而且每个partition是有序的</li><li>每个Segment以自己包含的第一条消息的offset + “.kafka” 命名</li><li>有一个索引文件，表明了每个segment下包含的log的offset范围<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">日志的组成</span><br><span class="line">message length ： 4 bytes (value: 1+4+n)</span><br><span class="line">&quot;magic&quot; value ： 1 byte </span><br><span class="line">CRC 校验码 ： 4 bytes </span><br><span class="line">消息内容 ： n bytes</span><br></pre></td></tr></table></figure></li></ul><h2 id="消息的读取是O-1-的（这句话待求证）"><a href="#消息的读取是O-1-的（这句话待求证）" class="headerlink" title="消息的读取是O(1)的（这句话待求证）"></a>消息的读取是O(1)的（这句话待求证）</h2><blockquote class="blockquote-center"><p>Kafka’s performance is effectively constant with respect to data size so storing data for a long time is not a problem </p></blockquote><ul><li>Kafka会保留所有的消息，与是否被消费无关</li><li>可以指定删除旧数据的策略， 时间/partition文件大小</li><li>文件的大小和多少，不会影响kafka的性能</li></ul><p><img src="/img/consumer and provider.png" alt=""></p><h2 id="Consumer保存自己消费的offset，consumer之间互不影响"><a href="#Consumer保存自己消费的offset，consumer之间互不影响" class="headerlink" title="Consumer保存自己消费的offset，consumer之间互不影响"></a>Consumer保存自己消费的offset，consumer之间互不影响</h2><ul><li>因此kafka的broker是无状态的，也不需要锁</li><li>consumer可以通过修改自己的offset达到重新消费消息的效果</li><li>consumer去broker pull消息</li></ul><h1 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h1><ul><li>producer 选择自己的每一条消息记录到哪个partition中</li><li>最简单的方式就是循环，可以保证负载均衡</li><li>也可以通过某些消息中的某些元素自定义</li></ul><h1 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h1><blockquote class="blockquote-center"><p>The way consumption is implemented in Kafka is by dividing up the partitions in the log over the consumer instances so that each instance is the exclusive consumer of a “fair share” of partitions at any point in time </p></blockquote><p><img src="/img/consumer-groups.png" alt=""></p><ul><li>consumer有group的概念，一个group的所有实例，一起消费相同的topic</li><li>每个消息只会被交付给consumer group中的一个实例</li><li>kafka 关于这个的实现方式是将 partition划分到消费者实例上，使得在任何时间点上，每个实例都是将partitions公平分享的独占消费者</li><li>关于这一点，newQMQ就有刻意的区别实现，做了动态的关联</li><li>这个对应关系，是由kafka的协议动态维护的，所以任何消费者实例的变化，都会导致对应关系的变化</li><li>不需要区分订阅或是广播，所有消息都是订阅，如果每个consumer有独一无二的group，就是广播</li><li>kafka只保证每个partition有序，不保证多个partition的顺序，所以整体来说，其实是不保证消息有序的，如果想要整体顺序消费，那么只能通过一个partitoon的方式实现，这样带来的后果是也只会有一个consumer消费消息</li><li>关于这一点，newQMQ也有做一些特殊的处理，如果真的想要强顺序的话，貌似是可以实现的，虽然不知道效果是不是和这个一样</li></ul><h1 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h1><ul><li>partition 分布在kafka的集群上，每个server处理数据并请求共享分区，每个 partition 被复制在多个(可配)服务器上以实现容错</li><li>每个 partition 有一个server是leader，0或多个followers</li><li>leader处理读写请求，其他followers被动复制</li><li>leader挂了，某个followers自动变为leader</li><li>每个server都扮演一些 partition 的leader，和另一些的follower，因此load在集群中很平衡</li><li>当然，以此推论，如果只有一个server，则独自扮演所有topic的所有partition的leader，并且没有follower</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;这是我对于kafka的学习过程中的一些笔记，可能大多数的信息来源于官方网站的翻译，以及网上的其他blog。&lt;/em&gt;&lt;br&gt;&lt;em&gt;也许会参杂着一些自己的思考和认知，如果你需要一个入门、基础知识的快速阅览，也许会适合你。&lt;/em&gt;&lt;br&gt;&lt;em&gt;resources: &lt;a href=&quot;http://www.infoq.com/cn/articles/kafka-analysis-part-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;infoQ&lt;/a&gt; &amp;amp; &lt;a href=&quot;http://kafka.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kafka官网&lt;/a&gt;&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://www.carryca.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MQ" scheme="http://www.carryca.com/tags/MQ/"/>
    
      <category term="Kafka" scheme="http://www.carryca.com/tags/Kafka/"/>
    
  </entry>
  
</feed>
